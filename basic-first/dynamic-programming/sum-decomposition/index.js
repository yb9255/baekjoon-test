const input = require('fs')
  .readFileSync('input2.txt')
  .toString()
  .split(' ')
  .map(Number);

const MOD = 1_000_000_000;
const [N, K] = input;

/**
 * 점화식 설명
 *
 * 1. dp[k][n]의 정의
 *    - dp[k][n]은 정수 n을 정확히 k개의 자연수(0 포함)로 나누는 경우의 수를 의미한다.
 *    - 예를 들어 dp[2][5]라면, 정수 5를 정확히 2개의 수로 표현하는 경우의 수를 저장한다.
 *    - 표현 순서가 다르면 다른 경우로 본다. (예: (1,4)와 (4,1)은 다른 경우)
 *
 * 2. dp[k][n]을 구하는 기본 아이디어
 *    - 우리는 n을 k개의 수로 만든다고 할 때,
 *      1) 마지막에 '0'을 추가하는 경우
 *      2) 기존에 만든 합을 1 늘려서 n을 맞추는 경우
 *      이렇게 두 가지로 나눌 수 있다.
 *
 * 3. 첫 번째 케이스 (마지막에 0을 붙이는 경우)
 *    - 예를 들어 dp[3][5]를 생각해보자.
 *    - 만약 마지막 숫자가 0이라면, 앞에 있는 (k - 1)개 숫자의 합이 이미 5가 되어야 한다.
 *    - 이 경우는 결국 "5를 (k - 1)개 숫자로 만든 경우"에서 0만 붙인 것이다.
 *    - 즉, dp[2][5]의 모든 경우의 수에 0을 추가하는 방식이다.
 *    - 이 경우의 수가 dp[k - 1][n]로 표현된다.
 *    - 결국 dp[k - 1][n]은 "n을 (k - 1)개의 숫자로 만든 뒤, 0을 하나 추가해서 k개로 만든 경우의 수"를 의미한다.
 *
 * 4. 두 번째 케이스 (합을 1 늘려서 맞추는 경우)
 *    - 다시 dp[3][5]를 생각해보자.
 *    - 만약 마지막에 들어오는 숫자가 1 이상이라면,
 *      이는 "n - 1"을 k개의 숫자로 만들고,
 *      그 중 하나의 숫자에 1을 더했다고 볼 수 있다.
 *    - 하지만 어떤 숫자에 1을 더했는지는 중요하지 않고,
 *      "n - 1을 k개의 숫자로 만든 모든 경우"가 그대로 유효하다.
 *    - 왜냐하면 경우의 수를 셀 때는 어떻게 더했든지,
 *      (중간에 어떤 숫자가 더 커지고 작아지고) 순열로 다르게 세니까
 *      그냥 n - 1을 k개의 숫자로 만든 경우의 수만큼 n이 되는 경우가 생긴다.
 *    - 그래서 dp[k][n - 1]을 가져오는 것이다.
 *    - dp[k][n - 1]은 "n - 1을 k개로 만들었던 모든 경우의 수"가 된다.
 *    - 이걸 이용해 "n을 k개로 만드는 경우의 수"로 확장시키는 것이다.
 *
 * 5. 핵심 정리
 *    - dp[k][n]는 이렇게 두 가지 경우의 수를 모두 더해서 만들어진다:
 *      dp[k][n] = dp[k - 1][n] + dp[k][n - 1]
 *    - dp[k - 1][n]는 "n을 (k - 1)개로 만드는 모든 방법의 수"로,
 *      여기에 0을 붙여 k개로 만드는 방식이다.
 *    - dp[k][n - 1]는 "n - 1을 k개로 만드는 모든 방법의 수"로,
 *      거기서 합만 1 증가시켜서 n으로 만들어지는 것이다.
 *
 * 6. 이 점화식을 계속 적용하면,
 *    - dp[k][n]를 채우기 위해 dp[k - 1][n]와 dp[k][n - 1]을 찾고
 *    - 그걸 또 찾기 위해 dp[k - 2][n], dp[k - 1][n - 1]을 찾고
 *    - 이런 식으로 점점 더 작은 문제로 쪼개져서,
 *      결국에는 dp[0][0] 같은 베이스 케이스에 도달하게 된다.
 *
 * 7. 베이스 케이스 설정
 *    - dp[0][0] = 1로 둔다.
 *    - 이는 "정수 0을 0개로 만드는 방법은 단 하나 존재한다"는 의미다. (아무것도 없는 상태)
 *    - 또한, dp[0][n] = 0 (n이 0이 아닐 때)는 "0개 숫자로 n을 만들 수 없다"는 뜻이다.
 *    - dp[k][0] = 1 (k가 0이 아닐 때)는 "합이 0이 되는 경우는 k개가 전부 0일 때 딱 1가지 존재한다"
 *
 * 8. 결론적으로 dp[k][n]는 다음을 반복하며 채워진다:
 *    - dp[k][n] = dp[k - 1][n] + dp[k][n - 1]
 *    - 이 과정을 통해 n을 k개 숫자로 만드는 모든 경우의 수가 정확히 누적된다.
 *    - 그리고 이 구조 덕분에 중복 없이 모든 케이스를 정확히 한 번씩만 계산하고,
 *      이를 통해서 아주 큰 n, k 값도 효율적으로 처리할 수 있게 된다.
 */

const dp = Array.from({ length: K + 1 }, () =>
  Array.from({ length: N + 1 }, (_, i) => (i === 0 ? 1 : 0)),
);

for (let k = 1; k <= K; k++) {
  for (let n = 1; n <= N; n++) {
    dp[k][n] = (dp[k][n - 1] + dp[k - 1][n]) % MOD;
  }
}

console.log(dp[K][N]);
