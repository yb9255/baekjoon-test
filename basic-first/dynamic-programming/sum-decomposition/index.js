const input = require('fs')
  .readFileSync('input2.txt')
  .toString()
  .split(' ')
  .map(Number);

const MOD = 1_000_000_000;
const [N, K] = input;

/** 점화식
 * 1. dp[n][k]는 n을 k개 만들 수있는 개수가 들어감
 *
 * 2. 합분해의 마지막 숫자가 0인 경우, 이전에 구한 값에 0만 추가하면 되므로 dp[n][k - 1] 와 갯수가 같음
 * e.g.) 6을 3개의 숫자로 표현한 표현 중 3 + 3 + 0이 있는데,
 * 이를 2개의 숫자로 표현하면 3 + 3이다.
 * 즉 2개의 숫자로 표현한 모든 경우의 수에 0만 붙이면
 * 3개로 만든 경우의 수에서 0으로 끝나는 케이스를 구할 수 있다.
 *
 * 3. 합분해의 마지막 숫자가 1인 경우, n - 1을 구한 값에 + 1만 추가하면 되므로 dp[n - 1][k]와 갯수가 같음
 * e.g.) 6을 3개의 숫자로 표현한 표현 중 3(2 + 1) + 2 + 1이 있는데,
 * 5를 3개의 숫자로 표현한 표현 중 2 + 2 + 1이 있다.
 * 즉 6보다 1 작은 모든 경우의 수에 1을 더하면
 * 3개로 만든 경우의 수에서 1로 끝나는 케이스를 구할 수 있다.
 *
 * 4. 2와 3의 합을 dp에 저장하면, 숫자 3은 1 ~ 2에 있는 모든 경우의 수를 포함하고, 숫자 4는 1 ~ 3의 모든 경우의 수를 포함하고..
 * 식으로 이전 값이 누적되기 때문에 3의 경우 dp[n - 1][k]만 구해도 이전 모든 경우의 수의 합을 구할 수 있다.
 */

const dp = Array.from({ length: K + 1 }, () =>
  Array.from({ length: N + 1 }, (_, i) => (i === 0 ? 1 : 0)),
);

for (let k = 1; k <= K; k++) {
  for (let n = 1; n <= N; n++) {
    dp[k][n] = (dp[k][n - 1] + dp[k - 1][n]) % MOD;
  }
}

console.log(dp[K][N]);
