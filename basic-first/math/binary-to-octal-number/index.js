const input = require('fs').readFileSync('input.txt').toString().trim();

// 1. 2진수를 8진수로 나누려면 digit 3개씩 묶어야 함.
// 3개씩 묶고 남은 숫자가 11 이런식이면 앞에 0을 붙여서 011로 만들어줘야 함.

// 2. 현재 2진수를 3으로 나눠서 2진수의 길이가 3의 배수인지 아닌지 확인
// 3으로 나눈 값이 딱 떨어지지 않는다면 10 이런 식으로 남는 숫자가 생긴다는 의미
// 즉, 딱 떨어지지 않는다면 길이를 더 늘려서 0을 앞에 붙여줘야 한다.

// 3. 3으로 나눈 값을 우선 올림 처리 해서 딱 떨어지는 값으로 처리한다.
// 내림이 되는 경우 현재 값을 3으로 나눈거보다 낮은 값으로 값이 되므로 무조건 올림

// 4. 올림 처리한 값에 3을 곱해서 현재 2진수 길이와 가장 가깝게 큰 3의 배수를 구한다.
// 5. 현재 2진수앞에 가장 가깝게 큰 3의 배수만큼 0을 붙여준다.
// 6. 3 digit씩 순회하면서 2진수를 8진수로 바꿔주고, 그걸 answer에 붙인다.

const paddedBinary = input.padStart(Math.ceil(input.length / 3) * 3, 0);
let answer = '';

for (let i = 0; i < paddedBinary.length; i += 3) {
  answer += parseInt(paddedBinary.slice(i, i + 3), 2).toString(8);
}

console.log(answer);

// 메소드를 쓰지 않고 직접 진법을 구하는 경우

// 0. 진법의 이해
// 진법은 기본적으로 "digit 위치가 어떤 숫자의 제곱으로 표시되는가"를 의미.
// e.g.) 10진법. digit 위치가 10의 제곱으로 표시됨 -> 321 == 3 * 10^2 + 2 * 10^1 + 1 * 10^0

// 8진법은 각 digit 위치가 8의 제곱으로 표시되는 수
// e.g.) 8진법 -> 345 == 3 * 8^2 + 4 * 8^1 + 5 * 8^0

// 2진법은 각 digit의 위치가 2의 제곱으로 표시되는 수
// e.g) 2진법 -> 11001100 == (1×2⁷) + (1×2⁶) + (0×2⁵) + (0×2⁴) + (1×2³) + (1×2²) + (0×2¹) + (0×2⁰)

// 그런데 8은 2^3이기 때문에 2진수의 세 digit의 묶음이 8진법의 1 digit과 값이 같음
// e.g.) (1×2²) + (0×2¹) + (0×2⁰) 는 총 자리값이 2^3
// (4 * 8^0) 역시 총 자리 값이 2^3이므로, 진법 기준 상 같은 위치를 표현하는 식이 됨.

// 그래서 011 / 001 / 100 세 비트로 쪼개고, 각 비트 묶음별로 2씩 곱해서 값을 구하면 0 ~ 7 사이의
// 값이 항상 나오기 때문에 8진법으로 표현이 가능하다.

// 원래는 011001의 경우 오른쪽부터 2^4 ~ 2^9을 더해야 되지만, digit으로 표시되는거기 때문에
// 2^0 ~ 2^2씩 구해도 괜찮다.

// 1. 2진법 비트 3개 === 8진법 비트 1개
// 2. 2진법 숫자가 3의 배수가 되도록 앞에 0을 추가
// 3. 오른쪽부터 비트를 3개씩 순회. x * 2^0부터 x * 2^2까지 값을 구하고 결과값에 더함.
// 4. 그 다음 비트를 3개씩 순회하면서 값을 계속 더해 나감.

const paddedBinary2 = input.padStart(Math.ceil(input.length / 3) * 3, 0);
let answer2 = '';

for (let i = paddedBinary2.length - 1; i > 0; i -= 3) {
  let sum = 0;

  for (let j = i; j >= Math.max(i - 2, 0); j--) {
    if (paddedBinary2[j] === '1') {
      sum += Math.pow(2, i - j);
    }
  }

  answer2 = sum + answer2;
}

console.log(answer2);
